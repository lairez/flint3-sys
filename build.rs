use std::{
    path::{Path, PathBuf},
    process::Command,
};

use anyhow::{Context, Result};

// Don't generate bindings for the following headers
#[allow(dead_code)]
static SKIP_HEADERS: &[&str] = &[
    "NTL-interface.h",
    "crt_helpers.h",
    "longlong_asm_clang.h",
    "longlong_asm_gcc.h",
    "longlong_div_gnu.h",
    "longlong_msc_arm64.h",
    "longlong_msc_x86.h",
    "mpfr_mat.h", // deprecated
    "mpfr_vec.h", // deprecated
    "gmpcompat.h",
    "fft_small.h", // seems to cause some issues, but not so
    // important, fft_small is still used by FLINT even if the header
    // is not exposed.
    "machine_vectors.h", // idem
    "mpn_extras.h",
    "gettimeofday.h",
];

struct Conf {
    out_dir: PathBuf,           // OUT_DIR from Cargo
    bindgen_extern_c: PathBuf, // $OUT_DIR/extern.c, generated by bindgen, see https://github.com/rust-lang/rust-bindgen/discussions/2405
    bindgen_flint_rs: PathBuf, // $OUT_DIR/flint.rs, generated by bindgen
    flint_include_dir: PathBuf, // $OUT_DIR/include, generated by `make install` from FLINT
    flint_lib_dir: PathBuf,    // $OUT_DIR/lib, idem
    flint_root_dir: PathBuf,   // $OUT_DIR/flint, copy of the source tree of FLINT
}

impl Conf {
    fn new() -> Self {
        let out_dir = PathBuf::from(std::env::var("OUT_DIR").unwrap())
            .canonicalize()
            .unwrap();
        Conf {
            out_dir: out_dir.clone(),
            bindgen_extern_c: out_dir.join("extern.c"),
            bindgen_flint_rs: out_dir.join("flint.rs"),
            flint_include_dir: out_dir.join("include"),
            flint_lib_dir: out_dir.join("lib"),
            flint_root_dir: out_dir.join("flint"),
        }
    }

    // Compile FLINT and install it with prefix `OUT_DIR`, so it populates
    // `$OUT_DIR/include` and `$OUT_DIR/lib`.
    fn build_flint(&self) -> Result<()> {
        Command::new("cp")
            .arg("-r")
            .arg("--update")
            .arg("flint")
            .arg(&self.out_dir)
            .output()
            .context("Could not copy FLINT source tree")?;

        if !self.flint_root_dir.join("configure").is_file() {
            Command::new("bash")
                .current_dir(&self.flint_root_dir)
                .arg("bootstrap.sh")
                .output()
                .context("FLINT compilation: ./bootstrap.sh failed")?;
        }

        if !self.flint_root_dir.join("Makefile").is_file() {
            Command::new("bash")
                .current_dir(&self.flint_root_dir)
                .arg("./configure")
                .arg("--prefix")
                .arg(&self.out_dir)
                .arg("--disable-shared") // it is not advised to generate dynamic libraries in crates
                //.arg(format!("--with-gmp={}", gmp_mpfr_dir.display()))
                //.arg(format!("--with-mpfr={}", gmp_mpfr_dir.display()))
                .output()
                .context("FLINT compilation: ./configure failed")?;
        }

        if !self.flint_root_dir.join("libflint.a").is_file() {
            Command::new("make")
                .current_dir(&self.flint_root_dir)
                .arg("-j")
                .output()
                .context("FLINT compilation: make failed")?;
        }

        Command::new("make")
            .current_dir(&self.flint_root_dir)
            .arg("install")
            .output()
            .context("FLINT compilation: make install failed")?;

        println!("cargo::metadata=LIB={}", self.flint_lib_dir);
        println!("cargo::metadata=INCLUDE={}", self.flint_include_dir);

        Ok(())
    }

    fn build_extern(&self) -> Result<()> {
        cc::Build::new()
            .file(&self.bindgen_extern_c)
            .flags(["-lflint", "-lgmp", "-lmpfr"])
            .flags([
                "-Wno-old-style-declaration",
                "-Wno-unused-parameter",
                "-Wno-sign-compare",
            ])
            .try_compile("extern")?;

        println!("cargo:rustc-link-lib=static=extern");
        Ok(())
    }
}

#[cfg(not(feature = "rerun-bindgen"))]
impl Conf {
    fn bindgen(&self) -> Result<()> {
        std::fs::copy(&Path::new("./bindgen/flint.rs"), &self.bindgen_flint_rs)
            .context("Failed to copy `bindgen/flint.rs`")?;
        std::fs::copy(&Path::new("./bindgen/extern.c"), &self.bindgen_extern_c)
            .context("Failed to copy `bindgen/extern.c`")?;
        Ok(())
    }
}

#[cfg(feature = "rerun-bindgen")]
impl Conf {
    // Compute the list of all FLINT headers (minus the one we skip)
    fn flint_headers(&self) -> Result<Vec<PathBuf>> {
        use std::{collections::HashSet, ffi::OsStr};

        let flint_header_dir = self.flint_include_dir.join("flint");
        anyhow::ensure!(
            flint_header_dir.join("flint.h").is_file(),
            "Cannot find `flint.h`"
        );

        // Now, list all the headers in `/usr/include/flint/`
        let entries = flint_header_dir.read_dir()?;
        let mut headers = Vec::new();

        let mut skip = HashSet::new();
        for file in SKIP_HEADERS {
            skip.insert(OsStr::new(*file));
        }

        let header_extension = OsStr::new("h");
        for entry in entries {
            let entry = entry?;
            let path = entry.path();
            if path.extension() != Some(header_extension) {
                continue;
            }
            if skip.contains(&path.file_name().unwrap()) {
                continue;
            }
            headers.push(path)
        }

        Ok(headers)
    }

    fn bindgen(&self) -> Result<()> {
        // All relevant FLINT headers
        let headers: Vec<_> = self.flint_headers()?;

        let mut builder = bindgen::Builder::default();
        for header in headers {
            let h = header.to_str().context("Non unicode path")?;
            builder = builder.allowlist_file(h).header(h);
            // We are using bindgen in allowlisting mode, see
            // https://rust-lang.github.io/rust-bindgen/allowlisting.html
            // This avoids bringing all of GMP in the binding
        }
        let bindings = builder
            .parse_callbacks(Box::new(bindgen::CargoCallbacks::new())) // useful to echo some cargo:rerun
            .derive_default(true) // useful to avoid too many MaybeUninit
            .derive_copy(false) // nothing (?) in FLINT is Copy
            .derive_debug(false)
            .wrap_static_fns(true) // deal with inline functions
            .wrap_static_fns_path(&self.bindgen_extern_c) // idem
            .generate_cstr(true) // recommended by bindgen's doc
            .merge_extern_blocks(true)
            .blocklist_function("__.*") // block internal items
            .blocklist_var("__.*") // block internal items
            .rust_target(bindgen::RustTarget::stable(82, 0).ok().unwrap())
            // There are still issues with 2024 edition
            // https://github.com/rust-lang/rust-bindgen/issues/3180
            .rust_edition(bindgen::RustEdition::Edition2021)
            .formatter(bindgen::Formatter::Prettyplease)
            .generate()?;

        bindings.write_to_file(&self.bindgen_flint_rs)?;

        // The maintenaire of `flint-ffi-sys` may use the environment variable
        // SAVE_BINDGEN_IN_SOURCE to save the result of bindgen and release it,
        // so that the use downstream do not have to run bindgen themselves.
        println!("cargo::rerun-if-env-changed=SAVE_BINDGEN_IN_SOURCE");
        if std::env::var("SAVE_BINDGEN_IN_SOURCE").is_ok() {
            std::fs::copy(&self.bindgen_flint_rs, &Path::new("./bindgen/flint.rs")).context(
                format!("Failed to copy `{}`", self.bindgen_flint_rs.display()),
            )?;
            std::fs::copy(&self.bindgen_extern_c, &Path::new("./bindgen/flint.rs")).context(
                format!("Failed to copy `{}`", self.bindgen_extern_c.display()),
            )?;
            println!("cargo::rerun-if-changed=bindgen/flint.rs");
            println!("cargo::rerun-if-changed=bindgen/extern.c");
        }

        Ok(())
    }
}

fn main() -> Result<()> {
    let conf = Conf::new();



    conf.build_flint()?;

    anyhow::ensure!(
        conf.flint_include_dir.join("flint/flint.h").is_file(),
        "Compilation is successful, but `flint/flint.h` is not where it should"
    );

    anyhow::ensure!(
        conf.flint_lib_dir.join("libflint.a").is_file(),
        "Compilation is successful, but `libflint.a` is not where it should"
    );


    conf.bindgen()?;

    anyhow::ensure!(conf.bindgen_extern_c.is_file(), "Cannot find `extern.c`");
    anyhow::ensure!(conf.bindgen_flint_rs.is_file(), "Cannot find `flint.rs`");


    conf.build_extern()?;

    Ok(())
}

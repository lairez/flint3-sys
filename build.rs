use std::{path::PathBuf, process::Command};

use anyhow::{Context, Result};

// WHAT?? More that 400 lines to build FLINT?. Hopefully every line will be clear after a few explanations.
//
// The pipeline is simple :
//
// STEP 1. Build FLINT, with the usual procedure (./configure, make, make install)
//
// STEP 2. Run bindgen, or simply copy the pregenerated files in the directory `./bindgen`
//
// STEP 3. Compile the `flintextern.c` file generated by bindgen which contains the inline functions.
//

// The input of bindgen is a set of header files. We take all FLINT headers
// minus the one below (either because they are irrelevant for a Rust bindings,
// or because they cause problems).
#[allow(dead_code)]
static SKIP_HEADERS: &[&str] = &[
    "NTL-interface.h",
    "config.h",
    "crt_helpers.h",
    "longlong_asm_clang.h",
    "longlong_asm_gcc.h",
    "longlong_div_gnu.h",
    "longlong_msc_arm64.h",
    "longlong_msc_x86.h",
    "mpfr_mat.h", // deprecated
    "mpfr_vec.h", // deprecated
    "gmpcompat.h",
    "fft_small.h", // seems to cause some issues, but not so
    // important, fft_small is still used by FLINT even if the header
    // is not exposed.
    "machine_vectors.h", // idem
    "mpn_extras.h",
    "gettimeofday.h",
    "profiler.h",
];

// We will spawn a lot of shell commands with Command::new. The properway to
// handle errors (capturing the output and checking the exit code) is a bit
// verbose, so there is this macro.
macro_rules! cmd {
    ($cmd: expr) => {
        let mut cmd = $cmd;

        // Save the command string for error reporting
        let cmd_string = format!("{:?}", cmd);

        // Launch the command. Use the ? operator, so the macro only works in a
        // function that return a anyhow::Result. Typical errors (like
        // `./condigure` failing because of a missing dependency) are not
        // catched here, only IO errors.
        let exit = cmd
            .output()
            .context(format!("Command {} did not execute normally", cmd_string))?;

        // Check the exit code
        if !exit.status.success() {
            // Report error
            anyhow::bail!(
                "Command failed\nCommand: {}\n===== stdout\n{}===== stderr\n{}\n",
                cmd_string,
                String::from_utf8_lossy(&exit.stdout),
                String::from_utf8_lossy(&exit.stderr),
            )
        }
    };
}

// This contains a few relevant paths.
struct Conf {
    out_dir: PathBuf,           // OUT_DIR from Cargo
    bindgen_extern_c: PathBuf, // $OUT_DIR/flintextern.c, generated by bindgen, see https://github.com/rust-lang/rust-bindgen/discussions/2405
    bindgen_flint_rs: PathBuf, // $OUT_DIR/flint.rs, generated by bindgen
    flint_include_dir: PathBuf, // $OUT_DIR/include, generated by `make install` from FLINT
    flint_lib_dir: PathBuf,    // $OUT_DIR/lib, idem
}

impl Conf {
    fn new() -> Self {
        // OUT_DIR is where cargo asks us to put the build artifacts
        let out_dir = PathBuf::from(std::env::var("OUT_DIR").unwrap())
            .canonicalize()
            .unwrap();
        Conf {
            out_dir: out_dir.clone(),
            bindgen_extern_c: out_dir.join("flintextern.c"),
            bindgen_flint_rs: out_dir.join("flint.rs"),
            flint_include_dir: out_dir.join("include"),
            flint_lib_dir: out_dir.join("lib"),
        }
    }

    // STEP 1.
    //
    // Compile FLINT and install it with prefix `OUT_DIR`, so it populates
    // `$OUT_DIR/include` and `$OUT_DIR/lib`.
    fn build_flint(&self) -> Result<()> {
        let flint_root_dir = self.out_dir.join("flint");

        // FLINT does not support out-of-tree compilation, so we copy the source
        let mut cp = Command::new("cp");
        cp.arg("-Rp") // keeps the timestamps, so it avoids to trigger unnecessary rebuild
            // .arg("--update") // copy only what we need
            .arg("flint")
            .arg(&self.out_dir);

        cmd! { cp } // lauch the command

        // We now follow the instructions in flint/INSTALL.md

        // Do not bootstrap if `configure` already exists
        if !flint_root_dir.join("configure").is_file() {
            let mut bootstrap = Command::new("sh");
            bootstrap.current_dir(&flint_root_dir).arg("./bootstrap.sh");

            cmd! { bootstrap }
        }

        // Do not configure if `Makefile` already exists. This is maybe a bit
        // optimistic, I guess that there are times where we want to refresh the
        // Makefile. But when? In most cases, we don't.
        if !flint_root_dir.join("Makefile").is_file() {
            let mut configure = Command::new("sh");

            configure
                .current_dir(&flint_root_dir)
                .arg("./configure")
                .arg("--prefix") // ask that the files are install in OUT_DIR, not `/usr`
                .arg(&self.out_dir)
                .arg("--disable-shared"); // it is not advised to generate dynamic libraries in crates

            // In case, we have the crate `gmp-mpfr-sys` available, we indicate
            // to the configuration scripts where to find the headers and the
            // lib files of GMP and MPFR.
            if cfg!(feature = "gmp-mpfr-sys") {
                configure
                    .arg(format!(
                        "--with-gmp-lib={}",
                        std::env::var("DEP_GMP_LIB_DIR")?
                    ))
                    .arg(format!(
                        "--with-gmp-include={}",
                        std::env::var("DEP_GMP_INCLUDE_DIR")?
                    ));
            }

            cmd! { configure }
        }

        // Compile, if `libflint.a` does not already exist
        if !flint_root_dir.join("libflint.a").is_file() {
            let mut make = Command::new("make");
            make.current_dir(&flint_root_dir).arg("-j");
            cmd! { make }
        }

        // Install in OUT_DIR
        let mut make_install = Command::new("make");
        make_install.current_dir(&flint_root_dir).arg("install");

        cmd! { make_install };

        // These are environment variables that will be accessible to crates
        // depending on flint3-sys. They will be named DEP_FLINT_LIB_DIR and
        // DEP_FLINT_INCLUDE_DIR. See the Cargo book for more details.
        println!("cargo::metadata=LIB_DIR={}", self.flint_lib_dir.display());
        println!(
            "cargo::metadata=INCLUDE_DIR={}",
            self.flint_include_dir.display()
        );

        Ok(())
    }

    // STEP 3.
    //
    // Build the file extern.c, which is generated by bindgen.
    fn build_extern(&self) -> Result<()> {
        cc::Build::new()
            .file(&self.bindgen_extern_c)
            .include(&self.flint_include_dir)
            .flags(["-lflint", "-lmpr", "-lgmp"])
            .flags([
                // remove compilation warnings, we cannot do much about them.
                "-Wno-old-style-declaration",
                "-Wno-unused-parameter",
                "-Wno-sign-compare",
            ])
            .try_compile("extern")?;

        Ok(())
    }
}

// STEP 2 (without `force-bindgen`)
//
// We copy the files in ./bindgen to the OUR_DIR.
#[cfg(not(feature = "force-bindgen"))]
impl Conf {
    fn bindgen(&self) -> Result<()> {
        println!(
            "cargo::rerun-if-changed={}",
            &self.bindgen_flint_rs.display()
        );
        println!(
            "cargo::rerun-if-changed={}",
            &self.bindgen_extern_c.display()
        );
        let mut cp = Command::new("cp");
        cp.arg("-Rp") // the -p flag avoids trigerring build.rs for no reason
            .arg("./bindgen/flint.rs")
            .arg(&self.bindgen_flint_rs);
        cmd! { cp };

        let mut cp = Command::new("cp");
        cp.arg("-Rp")
            .arg("./bindgen/flintextern.c")
            .arg(&self.bindgen_extern_c);
        cmd! { cp };
        Ok(())
    }
}

// STEP 2 (with `bindgen`)
//
// This is the tricky part.
#[cfg(feature = "force-bindgen")]
impl Conf {
    // Compute the list of all FLINT headers (minus the one we skip)
    fn flint_headers(&self) -> Result<Vec<PathBuf>> {
        use std::{collections::HashSet, ffi::OsStr};

        // When we arrive here, `make install` is completed, so the FLINT
        // headers are in $OUT_DIR/include/flint.
        let flint_header_dir = self.flint_include_dir.join("flint");

        // Sanity check: there must be a file $OUT_DIR/include/flint/flint.h
        anyhow::ensure!(
            flint_header_dir.join("flint.h").is_file(),
            "Cannot find `flint.h`"
        );

        // The header paths will be put here.
        let mut headers = Vec::new();

        // Construct a HashSet of headers to be skipped.
        let mut skip = HashSet::new();
        for file in SKIP_HEADERS {
            skip.insert(OsStr::new(*file));
        }

        // Iterate over all the files in $OUT_DIR/include/flint
        let entries = flint_header_dir.read_dir()?;
        let header_extension = OsStr::new("h");
        for entry in entries {
            let entry = entry?;
            let path = entry.path();

            if path.extension() != Some(header_extension) {
                // This is not a header (what can it be ?)
                continue;
            }
            if skip.contains(&path.file_name().unwrap()) {
                // This is in the skip set
                continue;
            }

            // This is a good header
            headers.push(path)
        }

        Ok(headers)
    }

    fn bindgen(&self) -> Result<()> {
        // All relevant FLINT headers
        let headers: Vec<_> = self.flint_headers()?;

        let mut builder = bindgen::Builder::default();

        // Add the headers to the configuration of bindgen
        for header in &headers {
            // when dealing with the file system, every single function maybe fail...
            let h = header.to_str().context("Non unicode path")?;

            builder = builder.allowlist_file(h).header(h);
            // We are using bindgen in allowlisting mode, see
            // https://rust-lang.github.io/rust-bindgen/allowlisting.html
            // This avoids bringing all of GMP in the binding
        }

        // bindgen will put the inline functions there
        let extern_tmp = self.out_dir.join("flintextern-abs.c");

        // It will probably never be the case in normal use, but bindgen does
        // not create the file if there are no inline fuctions. So we make sure
        // it is created.
        std::fs::write(&extern_tmp, b"")?;

        let bindings = builder
            // .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
            // useful to echo some cargo:force, but disabled because it triggers
            // too many recompilations.
            .derive_default(false) // use mem::zeroed() instead, or MaybeUninit
            .derive_copy(false) // nothing (?) in FLINT is Copy
            .derive_debug(false) // useless
            .wrap_static_fns(true) // deal with inline functions
            .wrap_static_fns_path(&extern_tmp) // idem
            .generate_cstr(true) // recommended by bindgen's doc
            .merge_extern_blocks(true) // why would we not?
            .blocklist_function("__.*") // block internal items
            .blocklist_var("__.*") // block internal items
            .rust_target(bindgen::RustTarget::stable(82, 0).ok().unwrap())
            // There are still issues with 2024 edition
            // https://github.com/rust-lang/rust-bindgen/issues/3180
            .rust_edition(bindgen::RustEdition::Edition2021)
            .formatter(bindgen::Formatter::Prettyplease)
            .generate()?;

        // After that, we have our bindings in OUT_DIR/flint.rs
        bindings.write_to_file(&self.bindgen_flint_rs)?;

        {
            // The file `extern-abs.c` contains #include directives with absolute
            // paths, we need to relativize them.
            use std::io::Write;

            // This the file where we write the modified code.
            // The file handle will be closed at the end of the scope.
            let mut extern_rel = std::io::BufWriter::new(
                std::fs::File::create(&self.bindgen_extern_c)
                    .context("Cannot open `flintextern.c`")?,
            );

            // This is the file where bindgen outputs the inline functions.
            let extern_tmp = std::fs::read_to_string(&extern_tmp)
                .context(format!("Cannot read `{}`", extern_tmp.display()))?;

            // Regular expression to match FLINT include directives. There is
            // one group that captures the part relative to $OUT_DIR/include.
            let include_re = regex::Regex::new(r##"^#include\s+".+(flint/[^/]+\.h)""##)?;

            // read line by line
            for line in extern_tmp.lines() {
                match include_re.captures(&line) {
                    // Remove the part corresponding to $OUT_DIR/include
                    Some(capt) => writeln!(
                        extern_rel,
                        r##"#include "{}""##,
                        capt.get(1).context("no capturing group")?.as_str()
                    )?,
                    // copy the line as-is
                    None => writeln!(extern_rel, "{line}")?,
                }
            }
        }

        // The maintenaire of `flint3-sys` may use the environment variable
        // KEEP_BINDGEN_OUTPUT to save the result of bindgen and release it,
        // so that the use downstream do not have to run bindgen themselves.
        // See README.md
        println!("cargo::rerun-if-env-changed=KEEP_BINDGEN_OUTPUT");
        if std::env::var("KEEP_BINDGEN_OUTPUT").is_ok() {
            std::fs::copy(
                &self.bindgen_flint_rs,
                &std::path::Path::new("./bindgen/flint.rs"),
            )
            .context(format!(
                "Failed to copy `{}`",
                self.bindgen_flint_rs.display()
            ))?;
            std::fs::copy(
                &self.bindgen_extern_c,
                &std::path::Path::new("./bindgen/flintextern.c"),
            )
            .context(format!(
                "Failed to copy `{}`",
                self.bindgen_extern_c.display()
            ))?;
        }

        Ok(())
    }
}

// Out the three steps together
fn main() -> Result<()> {
    let conf = Conf::new();

    /////////////////
    // build FLINT //
    /////////////////

    conf.build_flint()?;

    // make sure that we have the correct files at the correct place
    anyhow::ensure!(
        conf.flint_include_dir.join("flint/flint.h").is_file(),
        "Compilation is successful, but `flint/flint.h` is not where it should"
    );

    // idem
    anyhow::ensure!(
        conf.flint_lib_dir.join("libflint.a").is_file(),
        "Compilation is successful, but `libflint.a` is not where it should"
    );

    // Instruct cargo that he has to link against libflint.a and its dependencies.
    // The order seems to be important with some linkers...
    println!("cargo::rustc-link-lib=flint");
    println!("cargo::rustc-link-lib=mpfr");
    println!("cargo::rustc-link-lib=gmp");
    println!(
        "cargo::rustc-link-search=native={}",
        conf.flint_lib_dir.display()
    );

    if cfg!(feature = "gmp-mpfr-sys") {
        // I am not completely sure that this is useful
        println!(
            "cargo::rustc-link-search=native={}",
            std::env::var("DEP_GMP_LIB_DIR")?
        );
    }

    ////////////////////////
    // binding generation //
    ////////////////////////

    // Unless the feature `force-bindgen` is unable, this simply takes the files
    // from the directory `./bindgen`.
    conf.bindgen()?;

    anyhow::ensure!(
        conf.bindgen_extern_c.is_file(),
        "Cannot find `flintextern.c`"
    );
    anyhow::ensure!(conf.bindgen_flint_rs.is_file(), "Cannot find `flint.rs`");

    ////////////////////////////////
    // Compiling inline functions //
    ////////////////////////////////

    conf.build_extern()?;
    // No linking instruction is required here, this is handled by `cc`.

    Ok(())
}
